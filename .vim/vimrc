" core setup
set mouse=a
let mapleader= " "
set title
set number relativenumber
set showmatch
set hlsearch

" enable plugins
filetype plugin on

" install plug.vim on new on new machines
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dir https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" plugins
call plug#begin('~/.vim/plugged')
Plug 'junegunn/fzf.vim'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'scrooloose/nerdtree'
Plug 'airblade/vim-gitgutter'
Plug 'sheerun/vim-polyglot'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-sensible'
Plug 'mbbill/undotree'
Plug 'SirVer/ultisnips'
Plug 'dense-analysis/ale'

" theme + color
Plug 'kristijanhusak/vim-hybrid-material'
call plug#end()
set background=dark
colorscheme hybrid_material
set termguicolors
let g:is_posix = 1 " shell for syntax highlighting purposes.

" git
set signcolumn=yes
g:gitgutter_map_keys = 0
" undotree
nnoremap <leader>u :UndotreeToggle<cr>
if has("persistent_undo")
  set undodir=$HOME/.cache/vim/persistent_undo
  set undofile
endif

" only show cursor line in active window/pane
augroup CursorLine
  au!
  au VimEnter,WinEnter,BufWinEnter * setlocal cursorline
  au WinLeave * setlocal nocursorline
augroup END

" tabs vs spaces
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab

" {{{ fzf
nnoremap <leader>fb :Buffer<CR>
nnoremap <leader>fh :History<CR>
nnoremap <leader>fz :FZF<CR>
nnoremap <leader>fg :GFiles<CR>
nnoremap <leader>fa :Ag<CR>
nnoremap <leader>fl :BLines<CR>
nnoremap <leader>fc :Commands<CR>
let $FZF_DEFAULT_OPTS = "--layout=reverse"

" fzf in floating window https://github.com/junegunn/fzf.vim/issues/664
function! CreateCenteredFloatingWindow()
    let width = min([&columns - 4, max([80, &columns - 20])])
    let height = min([&lines - 4, max([20, &lines - 10])])
    let top = ((&lines - height) / 2) - 1
    let left = (&columns - width) / 2
    let opts = {'relative': 'editor', 'row': top, 'col': left, 'width': width, 'height': height, 'style': 'minimal'}

    let top = "â•­" . repeat("â”€", width - 2) . "â•®"
    let mid = "â”‚" . repeat(" ", width - 2) . "â”‚"
    let bot = "â•°" . repeat("â”€", width - 2) . "â•¯"
    let lines = [top] + repeat([mid], height - 2) + [bot]
    let s:buf = nvim_create_buf(v:false, v:true)
    call nvim_buf_set_lines(s:buf, 0, -1, v:true, lines)
    call nvim_open_win(s:buf, v:true, opts)
    set winhl=Normal:Floating
    let opts.row += 1
    let opts.height -= 2
    let opts.col += 2
    let opts.width -= 4
    call nvim_open_win(nvim_create_buf(v:false, v:true), v:true, opts)
    au BufWipeout <buffer> exe 'bw '.s:buf
endfunction
let g:fzf_layout = { 'window': 'call CreateCenteredFloatingWindow()' }
" }}} fzf
"
" NERDTree open and open on current
noremap <leader><leader> :NERDTreeToggle<CR>
noremap <leader>n :NERDTreeFind<cr>
noremap <leader>s :NERDTreeFind<cr><C-W><C-P>
let g:NERDTreeQuitOnOpen = 1
let NERDTreeShowHidden=1
let NERDTreeShowLineNumbers=1

" if the only window open is NERDTree, close it
augroup vimrcEx
  autocmd!
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
augroup END

" %% to %:h to get active file dir in ex mode
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" change cursor shape when in insert mode
let &t_SI = "\e[6 q"
let &t_EI = "\e[2 q"

" {{{ Custom macros
" JS/TS: console.log the inner word one line below
autocmd FileType javascript,typescript,typescriptreact nnoremap <leader>rp viw"0yoconsole.log('0', 0);
autocmd FileType javascript,typescript,typescriptreact vnoremap <leader>rp "0yoconsole.log('0', 0);
" Python print next line
autocmd FileType python nnoremap <leader>rp viw"0yoprint('0', 0)
autocmd FileType python vnoremap <leader>rp "0yoprint('0', 0)

" Copy filepath to vim clipboard (Path Vim)
nnoremap <leader>pv :let @" = expand("%")
" Copy filepath to system clipboard (Path Clipboard)
nnoremap <leader>pc :let @+ = expand("%")
" Copy word under cusor to system clipboard (Clipboard)
nnoremap <leader>wc "+yiw
" }}}

" disable exmode and commandline search
map q: <Nop>
nnoremap Q <nop>

" {{{ stuff from https://github.com/thoughtbot/dotfiles
augroup vimrcEx
  autocmd!
  " When editing a file, always jump to the last known cursor position.
  " Don't do it for commit messages, when the position is invalid, or when
  " inside an event handler (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

  " Set syntax highlighting for specific file types
  autocmd BufRead,BufNewFile *.md set filetype=markdown
  autocmd BufRead,BufNewFile .{jscs,jshint,eslint}rc set filetype=json
augroup END
" When the type of shell script is /bin/sh, assume a POSIX-compatible
"
" Display extra whitespace
set list listchars=tab:Â»Â·,trail:Â·,nbsp:Â·

" Use one space, not two, after punctuation.
set nojoinspaces

" Open new split panes to right and bottom, which feels more natural
set splitbelow
set splitright

" Quicker window movement
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l
" }}}

" {{{ debugging/misc hacks
" F12 to fix syntax highlighting when needed https://vim.fandom.com/wiki/Fix_syntax_highlighting
noremap <F12> <Esc>:syntax sync fromstart<CR>
inoremap <F12> <C-o>:syntax sync fromstart<CR>

" Load all plugins and helptags
packloadall
silent! helptags ALL

" ALE
let g:ale_linters = {
\  'python': ['pyls'],
\}
let g:ale_fixers = {
\  'python': ['isort', 'black', 'pyls'],
\}
let g:ale_set_balloons = 1 " use balloons for ALEHover
let g:ale_lint_on_insert_leave = 1

nmap <leader>lg :ALEGoToDefinition<CR>
nmap <leader>lG :ALEGoToDefinitionInVSplit<CR>
nmap <leader>LG :ALEGoToDefinitionInVSplit<CR>
nmap <leader>lk :ALEDocumentation<CR>
nmap <leader>lh :ALEHover<CR>
nmap <leader>lr :ALEFindReferences<CR>
nmap <leader>ln :ALERename<CR>
nmap <leader>ls :ALESymbolSearch<CR>
nmap <leader>ll :ALELint<CR>
nmap <leader>lc :ALEReset<CR>
nmap <leader>le :ALEEnable<CR>
nmap <leader>ld :ALEDisable<CR>
